// Copyright (c) 2017-2018, Lawrence Livermore National Security, LLC.
// Produced at the Lawrence Livermore National Laboratory. LLNL-CODE-734707.
// All Rights reserved. See files LICENSE and NOTICE for details.
//
// This file is part of CEED, a collection of benchmarks, miniapps, software
// libraries and APIs for efficient high-order finite element and spectral
// element discretizations for exascale applications. For more information and
// source code availability see http://github.com/ceed.
//
// The CEED research is supported by the Exascale Computing Project 17-SC-20-SC,
// a collaborative effort of two U.S. Department of Energy organizations (Office
// of Science and the National Nuclear Security Administration) responsible for
// the planning and preparation of a capable exascale ecosystem, including
// software, applications, hardware, advanced system engineering and early
// testbed platforms, in support of the nation's exascale computing imperative.

// *****************************************************************************
static inline int CeedPowInt(int base, int power) {
  int result = 1;
  while (power) {
    if (power & 1) result *= base;
    power >>= 1;
    base *= base;
  }
  return result;
}

// *****************************************************************************
static int kCeedTensorContract(const int transpose,
                               const int A, const int B,
                               const int C, const int J,
                               const double *t,
                               const int tmode,
                               const int Add,
                               const double *u, double *v) {
  const int tstride0 = transpose?1:B;
  const int tstride1 = transpose?J:1;
  printf("ts0=%d, ts1=%d, %d %d %d %d %d",tstride0,tstride1,A,B,C,J,tmode);
  for (int a=0; a<A; a++) {
    for (int j=0; j<J; j++) {
      if (!Add) {
        for (int c=0; c<C; c++) v[(a*J+j)*C+c] = 0.0;
      }
      for (int b=0; b<B; b++) {
        for (int c=0; c<C; c++) {
          v[(a*J+j)*C+c] += t[j*tstride0 + b*tstride1] * u[(a*B+b)*C+c];
          printf("\n(a*J+j)*C+c=%d",(a*J+j)*C+c);
          //v[(a*J+j)*C+c] = 9.8765;
        }
      }
    }
  }
  return 0;
}

// *****************************************************************************
kernel void kZero(double* v) {
  for (int e=0; e<nelem; e++; tile(TILE_SIZE)) {
    if (e >= nelem) continue;
    const int e_offset = e*Q1d*nc*(dim+2);
    double *v = v+e_offset;
    for (int i = 0; i < vsize; i++)
      v[i] = 0.0;
  }
}

// *****************************************************************************
kernel void kInterp(const int transpose, const int tmode,
                    const int P, const int Q,
                    const int _pre, const int _post,
                    double *tmp0,double *tmp1,double *interp1d,
                    double *d_u, double *d_v){
  for (int e=0; e<nelem; e++; tile(TILE_SIZE)) {
    if (e >= nelem) continue;
    const int u_offset = e*nc*vsize;
    const int v_offset = e*Q*nc*(dim+2);
    double *o_u = d_u+u_offset;
    double *o_v = d_v+v_offset;
    int pre = _pre, post = _post;
    for (int d=0; d<dim; d++) {
      kCeedTensorContract(transpose,
                          pre,P,post,Q,
                          interp1d, tmode,
                          transpose&&(d==dim-1),
                          d==0?o_u:((d%2)==0)?tmp0:tmp1,
                          d==dim-1?o_v:(((d+1)%2)==0)?tmp0:tmp1);
      pre /= P;
      post *= Q;
    }
    if (!transpose) o_v += nqpt;else o_u += nqpt;
  }
}

// *****************************************************************************
kernel void kGrad(const int transpose, const int tmode,                  
                  double *tmp0, double *tmp1, double *grad1d, double *interp1d,
                  double *d_u, double *d_v){
  const int P = transpose?Q1d:P1d;
  const int Q = transpose?P1d:Q1d;
  printf("\n\tP=%d, Q=%d:",P,Q);
  for (int e=0; e<nelem; e++; tile(TILE_SIZE)) {
    if (e >= nelem) continue;
    const int u_offset = e*(nc*vsize);
    const int v_offset = e*(Q*nc*(dim+2));
    const double *o_u = d_u+u_offset;
    double *o_v = d_v+v_offset;
    for (int p=0; p<dim; p++) {
      int pre = ndof*CeedPowInt(P,dim-1);
      int post = 1;
      for (int d=0; d<dim; d++) {
        printf("\n\t\tpre=%d",pre);
        printf(", post=%d",post);
        printf(", d==0: %s",d==0?"yes":"no");
        printf(", d%%2=%d ",d%2);
        printf(", d==dim-1: %s",d==dim-1?"yes":"no");
        printf(", (d+1)%%2=%d ",(d+1)%2);
        kCeedTensorContract(transpose,
                            pre,P,post,Q,
                            (p==d)?grad1d:interp1d,
                            tmode, transpose&&(d==dim-1),
                            d==0?o_u:((d%2)==0)?tmp0:tmp1,
                            d==dim-1?o_v:(((d+1)%2)==0)?tmp0:tmp1);
        pre /= P;
        post *= Q;
      }
      if (!transpose) o_v += nqpt;else o_u += nqpt;
    }
  }
}

// *****************************************************************************
kernel void kWeight(const int Q, double *qweight1d, double* d_v){
  for (int e=0; e<nelem; e++; tile(TILE_SIZE)) {
    if (e >= nelem) continue;
    const int v_offset = e*(Q*nc*(dim+2))+nqpt;
    double *v = d_v+v_offset;
    for (int k=0; k<(Q*nc*(dim+2)); k++) {
      printf("\n\t %f",v[k]);
    }
    for (int d=0; d<dim; d++) {
      const int pre = CeedPowInt(Q,dim-d-1);printf("\n\tQ=%d, pre=%d",Q,pre);
      const int post = CeedPowInt(Q,d);printf(", post=%d: ",post);
      for (int i=0; i<pre; i++) {
        for (int j=0; j<Q; j++) {
          for (int k=0; k<post; k++) {
            printf(" k%d",(i*Q+j)*post+k);
            v[(i*Q+j)*post+k] = 1.2345;//qweight1d[j]*(d==0?1.0:v[(i*Q+j)*post+k]);
          }
        }
      }
    }
    for (int k=0; k<(Q*nc*(dim+2)); k++) {
      printf("\n\t after %f",v[k]);
    }
  }
}
